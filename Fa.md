# 🚀 کوانتوم‌لیست: ویجت لیست انقلابی برای فلاتر 🚀

**یک ویجت لیست فوق‌العاده پرسرعت، غنی از امکانات و با انیمیشن‌های زیبا برای فلاتر که رندرینگ اتمی، مدیریت وضعیت پیشرفته و جلوه‌های بصری خیره‌کننده را با کمترین تلاش ممکن می‌سازد.**

---
<p align="center">
  <img src="https://placehold.co/800x400/1E1E1E/FFFFFF?text=Your+Awesome+Project+GIF+Here" alt="تصویری از دموی پروژه"/>
</p>

### **[مشاهده دموی زنده!](https://shoghshahadat.github.io/QuantumList/)** | **[English](https://github.com/ShoghShahadat/QuantumList/blob/main/README.md)**

---

## ۱. چرا کوانتوم‌لیست به وجود آمد؟

در دنیای فلاتر، ساخت لیست‌های پویا یک امر اساسی است. اما با پیچیده‌تر شدن لیست‌ها، توسعه‌دهندگان با چالش‌های دردناکی روبرو می‌شوند:
- **بازسازی‌های غیرضروری (Unnecessary Rebuilds):** فراخوانی `setState` برای به‌روزرسانی یک آیتم، کل لیست را مجبور به بازسازی می‌کند که باعث افت فریم و کندی برنامه می‌شود.
- **جهنم مدیریت وضعیت (State Management Hell):** مدیریت یک لیست با انواع مختلف آیتم‌ها (مانند فید خبری) نیازمند منطق پیچیده و کدهای تکراری فراوان است.
- **پیچیدگی انیمیشن‌ها:** پیاده‌سازی انیمیشن‌های هماهنگ و زیبا اغلب به معنای کشتی گرفتن با `AnimatedList`، `TickerProvider` و محاسبات پیچیده است.

**کوانتوم‌لیست برای حل این مشکلات ساخته شده است.** این پکیج یک معماری کاملاً جدید ارائه می‌دهد که ساخت لیست‌های پیچیده، پرسرعت و خیره‌کننده را نه تنها ممکن، بلکه *آسان* می‌کند.

---

## ۲. مزیت کوانتومی: یک واقعیت جدید برای لیست‌ها

| قابلیت | `ListView`/`GridView` استاندارد | `QuantumList` | **برتری متحول‌کننده** |
| :--- | :--- | :--- | :--- |
| **استراتژی بازسازی** | اغلب نیازمند `setState` روی ویجت والد است که آیتم‌های زیادی را بازسازی می‌کند. | **آپدیت‌های اتمی:** فقط ویجتی که تغییر کرده را بازسازی می‌کند. | ✅ **افزایش عملکرد خیره‌کننده.** یک تیکر زنده بورس را در لیستی با ۱۰۰۰ آیتم بدون هیچ لگی آپدیت کنید. |
| **مدیریت وضعیت** | برای لیست‌های پیچیده نیازمند مدیریت وضعیت خارجی (Provider, BLoC) است. | **معماری کنترلر دوگانه:** کنترلرهای داخلی و قدرتمند برای هر سناریویی. | ✅ **منطق به شدت ساده‌تر.** یک فید خبری پیچیده را به سادگی یک لیست معمولی مدیریت کنید. |
| **انیمیشن آیتم‌ها** | نیازمند تنظیمات دستی با `AnimatedList` و کنترلرهای پیچیده است. | **انیمیشن و رقص‌پردازی داخلی:** کتابخانه غنی از انیمیشن‌ها و هماهنگی‌ها. | ✅ **رابط کاربری سینمایی در چند دقیقه.** انیمیشن‌های موجی یا پلکانی را با یک خط کد بسازید. |
| **ویژگی‌های پیشرفته** | برای قابلیت‌هایی مثل undo/redo یا هدرهای چسبان، نیازمند چندین پکیج و کد سفارشی است. | **همه‌چیز در یک پکیج:** سفر در زمان، آیتم‌های مغناطیسی، دگردیسی چیدمان و... | ✅ **توسعه سریع‌تر با کدبیس تمیزتر.** دیگر دنبال پکیج نگردید؛ قدرت همینجاست! |
| **تنوع ویجت‌ها** | مدیریت لیست‌هایی با انواع ویجت‌های مختلف می‌تواند طاقت‌فرسا باشد. | **کنترلر ویجت-شناسه:** لیست‌های متنوع را به راحتی با شناسه‌های منحصر به فرد مدیریت کنید. | ✅ **ابزار نهایی برای UI مدرن.** عالی برای فیدها، داشبوردها و محتوای پویا. |

---

## ۳. اصول کوانتومی: تشریح مفاهیم اصلی

برای استفاده کامل از قدرت کوانتوم‌لیست، درک اصول اصلی آن ضروری است.

### ⚛️ اصل شماره ۱: رندرینگ اتمی

این قلب تپنده عملکرد کوانتوم‌لیست است. به طور سنتی، وقتی یک آیتم را در لیست آپدیت می‌کنید، ممکن است `setState()` را روی ویجت والد فراخوانی کنید که باعث بازسازی تمام آیتم‌های موجود در صفحه می‌شود. این کار فوق‌العاده ناکارآمد است.

**کوانتوم‌لیست این مشکل را با مفهوم "اتم" حل می‌کند.**

یک "اتم" کوچکترین واحد ممکن از UI شماست که باید با تغییر داده‌های مخصوص به خودش، بازسازی شود. کوانتوم‌لیست تضمین می‌کند که وقتی شما `controller.update()` را فراخوانی می‌کنید، فقط و فقط "اتم" مربوط به همان یک آیتم بازسازی می‌شود و بقیه دست‌نخورده باقی می‌مانند.

**چگونه کار می‌کند؟**
`QuantumListController` یک استریم (`updateStream`) دارد. وقتی شما `update(id, newWidget)` را صدا می‌زنید، کنترلر ایندکس آن آیتم را پیدا کرده و *فقط همان ایندکس* را به استریم ارسال می‌کند. در داخل، هر آیتم در `QuantumList` درون یک `StreamBuilder` قرار گرفته که به این استریم گوش می‌دهد اما آن را برای *ایندکس خودش فیلتر می‌کند*. این یعنی فقط ویجتی که قرار است آپدیت شود، واکنش نشان می‌دهد.

### ✨ نگاه عمیق: متد کمکی `.atom()`

با اینکه می‌توانید به صورت دستی یک `StreamBuilder` برای گوش دادن به آپدیت‌ها تنظیم کنید، کوانتوم‌لیست یک راه حل بسیار زیباتر ارائه می‌دهد: متد کمکی `.atom()`.

**.atom() چیست؟**
این متد یک `extension` راحت روی `Widget` است. این یک پوشش تمیز دور منطق `StreamBuilder` است که در بالا توضیح داده شد. تنها وظیفه آن گوش دادن به استریم آپدیت کنترلر و بازسازی ویجتی است که به آن متصل شده؛ اگر و تنها اگر آپدیت برای ایندکس مخصوص آن باشد.

**چرا باید از آن استفاده کنید؟**
کد شما را تمیزتر، خواناتر و کم‌خطاتر می‌کند. این متد به وضوح نیت شما را نشان می‌دهد: "این ویجت باید به صورت اتمی آپدیت شود."

**تفاوت را ببینیم:**

**قبل (روش دستی):**
```dart
// در animationBuilder شما:
animationBuilder: (context, index, entity, animation) {
  // پیچیدن دستی در یک StreamBuilder برای مدیریت آپدیت‌های اتمی.
  // این کد طولانی است و ممکن است فراموش شود.
  return StreamBuilder<int>(
    stream: _controller.updateStream.where((updatedIndex) => updatedIndex == index),
    builder: (context, snapshot) {
      // حالا ویجت اصلی را می‌سازیم
      return QuantumAnimations.scaleIn(context, entity.widget, animation);
    }
  );
}
```

**بعد (روش زیبای `.atom()`):**
```dart
// در animationBuilder شما:
animationBuilder: (context, index, entity, animation) {
  // انیمیشن را اعمال کنید، سپس آن را به صورت اتمی هوشمند کنید. تمیز و ساده.
  return QuantumAnimations.scaleIn(context, entity.widget, animation)
      .atom(_controller, index);
}
```
همانطور که می‌بینید، `.atom()` کدهای تکراری را حذف کرده و یک خط کد خوانا و گویا برای شما باقی می‌گذارد. این روش پیشنهادی برای اطمینان از شرکت ویجت‌های شما در سیستم رندرینگ اتمی است.

### 👑 اصل شماره ۲: معماری کنترلر دوگانه

هیچ راه‌حل یکسانی برای مدیریت همه لیست‌ها وجود ندارد. کوانتوم‌لیست با ارائه دو نوع کنترلر قدرتمند و متمایز، این واقعیت را به رسمیت می‌شناسد.

| کنترلر | `QuantumWidgetController` (انقلابی) | `FilterableQuantumListController<T>` (کلاسیک) |
| :--- | :--- | :--- |
| **ایده اصلی** | مدیریت لیستی از `Widget`ها به طور مستقیم با شناسه‌های `String` منحصر به فرد. | مدیریت لیستی از `Data Model`های ساختاریافته (مانند `User`, `Product`). |
| **بهترین برای** | **لیست‌های ناهمگون:** فیدهای خبری، داشبوردها، صفحات تنظیمات و هر UI با محتوای ترکیبی. | **لیست‌های همگون:** لیست کاربران، محصولات، ایمیل‌ها و هر چیزی با ساختار داده یکسان. |
| **نقاط قوت** | انعطاف‌پذیری فوق‌العاده، عدم نیاز به مدل داده، عالی برای UIهای پویا. | فیلترینگ و مرتب‌سازی داخلی با عملکرد بالا، امنیت نوع داده (type safety). |
| **چه زمانی استفاده شود** | وقتی UI شما مجموعه‌ای از کامپوننت‌های متفاوت است. | وقتی UI شما نمایشی مستقیم از یک لیست داده است. |

---

## ۴. دنیایی از قابلیت‌ها در دستان شما

کوانتوم‌لیست فراتر از یک لیست است؛ یک اکوسیستم کامل برای ساخت UIهای پویاست. در اینجا نگاهی سریع به نحوه فعال‌سازی قدرتمندترین ویژگی‌های آن می‌اندازیم.

* **🎬 انیمیشن و رقص‌پردازی پیشرفته:** با انیمیشن‌های هماهنگ و خیره‌کننده به لیست خود جان ببخشید.
  ```dart
  QuantumList(
    // این یک خط یک افکت موجی زیبا ایجاد می‌کند!
    choreography: QuantumChoreography.wave(),
    animationDuration: const Duration(milliseconds: 1200),
    ...
  );
  ```

* **✨ بوردرهای کوانتومی:** آیتم‌های خود را برجسته کنید.
  ```dart
  // ۱. یک کنترلر بوردر بسازید و متصل کنید
  final _borderController = QuantumBorderController();
  QuantumList(borderController: _borderController, ...);
  
  // ۲. یک بوردر گرادیانت متحرک و خیره‌کننده به یک آیتم خاص اضافه کنید
  _borderController.addBorder(
    borderId: "highlight_border",
    targetEntityId: "item-to-highlight",
    border: QuantumBorder.animatedGradient(),
  );
  ```

* **👽 دگردیسی چیدمان:** لمسی از جادو. به نرمی بین چیدمان لیست و گرید جابجا شوید.
  ```dart
  // فقط پراپرتی 'type' را تغییر دهید و کوانتوم‌لیست انیمیشن را مدیریت می‌کند!
  QuantumList(
    key: ValueKey(_listType), // از یک کلید برای فعال کردن انیمیشن استفاده کنید
    type: _listType, // می‌تواند QuantumListType.list یا QuantumListType.grid باشد
    ...
  );
  ```

* **🧲 آیتم‌های مغناطیسی (هدرهای چسبان):** هرگز زمینه را از دست ندهید.
  ```dart
  // به سادگی یک موجودیت را به عنوان مغناطیسی علامت‌گذاری کنید تا به هدر چسبان تبدیل شود
  _controller.add(
    QuantumEntity(id: "header-a", widget: SectionHeader(title: "Section A"), isMagnetic: true)
  );
  ```

* **⏳ سفر در زمان (Undo/Redo):** دیگر اشتباه نکنید.
  ```dart
  // ۱. از کنترلر سفر در زمان استفاده کنید
  final _controller = TimeTravelQuantumWidgetController();
  
  // ۲. دکمه‌های Undo/Redo را اضافه کنید
  ElevatedButton(onPressed: _controller.undo, child: Text("Undo"));
  ```

* **👆 مرتب‌سازی با کشیدن و رها کردن:** تعامل کاربری بصری.
  ```dart
  QuantumList(
    // به همین سادگی.
    isReorderable: true,
    ...
  );
  ```

* **📜 صفحه‌بندی هوشمند (Smart Pagination):** برای لیست‌های بی‌نهایت.
  ```dart
  // کنترلر، منطق دریافت صفحات هنگام اسکرول کاربر را مدیریت می‌کند
  final _controller = PaginatedQuantumListController<Product>(
    // تابع شما برای دریافت داده از API
    (page) => fetchProductsFromApi(page), 
    // یک ویجت لودینگ سفارشی که در انتهای لیست نمایش داده می‌شود
    loadingIndicator: Center(child: CircularProgressIndicator()),
  );
  ```

* **↔️ کنش‌های سوایپ:** تجربه‌ی کاربری تمیز و مدرن.
  ```dart
  // هر ویجتی را بپوشانید تا قابل سوایپ شود
  QuantumSwipeAction(
    rightActions: [ /* اکشن حذف */ ],
    leftActions: [ /* اکشن آرشیو */ ],
    child: MyEmailListItem(),
  );
  ```

---

## ۵. نصب

این را به فایل `pubspec.yaml` پروژه خود اضافه کنید:

```yaml
dependencies:
  quantum_list: ^1.3.0 # با آخرین نسخه جایگزین کنید
```

سپس، با اجرای دستور زیر آن را نصب کنید:
```shell
flutter pub get
```

---

## ۶. تسلط بر کوانتوم‌لیست: مثال‌های کاربردی

### روش انقلابی ویجت-شناسه (مثال: یک فید خبری پویا)

```dart
// ۱. کنترلر را بسازید
final _feedController = QuantumWidgetController();

// ۲. UI را بسازید و از .atom() برای بهینه‌سازی استفاده کنید
QuantumList<QuantumEntity>(
  controller: _feedController,
  animationBuilder: (context, index, entity, animation) {
    return QuantumAnimations.slideInFromBottom(context, entity.widget, animation)
        .atom(_feedController, index); // آن را اتمی کنید!
  },
);

// ۳. فید را به صورت پویا از هر جای برنامه مدیریت کنید
void addBreakingNews() {
  final newsId = "news_${DateTime.now().millisecondsSinceEpoch}";
  _feedController.add(
    QuantumEntity(id: newsId, widget: BreakingNewsCard(headline: "کوانتوم‌لیست دنیا را گرفت!"))
  );
}
```

### روش کلاسیک مدل-داده (مثال: یک لیست کاربران قابل فیلتر)

```dart
// ۱. مدل و کنترلر خود را تعریف کنید
class User { /* ... */ }
final _userController = FilterableQuantumListController<User>(_users);

// ۲. UI را بسازید
QuantumList<User>(
  controller: _userController,
  animationBuilder: (context, index, user, animation) {
    return UserCard(user: user).atom(_userController, index);
  },
);

// ۳. به راحتی فیلتر و مرتب کنید
_userController.filter((user) => user.name.startsWith('A'));
_userController.sort((a, b) => a.name.compareTo(b.name));
```

---

## ۷. کدکس کوانتومی: مرجع کامل API

### ویجت `QuantumList<T>`

| پراپرتی | نوع | توضیحات |
| :--- | :--- | :--- |
| `controller` | `QuantumListController<T>` | **الزامی.** کنترلری که وضعیت لیست را مدیریت می‌کند. |
| `animationBuilder`| `Function` | **الزامی.** یک سازنده که برای یک آیتم و انیمیشن ورود آن، یک ویجت برمی‌گرداند. |
| `type` | `QuantumListType` | نوع چیدمان: `.list` (پیش‌فرض) یا `.grid`. |
| `gridDelegate` | `SliverGridDelegate` | وقتی `type` برابر `.grid` است، الزامی است. |
| `isReorderable` | `bool` | قابلیت مرتب‌سازی با کشیدن و رها کردن را فعال می‌کند. پیش‌فرض `false` است. |
| `choreography` | `QuantumChoreography` | توالی انیمیشن آیتم‌ها را تعریف می‌کند (مثلاً `QuantumChoreography.wave()`). |
| `borderController` | `QuantumBorderController` | سیستم بوردر کوانتومی را به لیست متصل می‌کند. |
| `scrollController` | `ScrollController` | یک کنترلر اسکرول خارجی اختیاری. |
| `animationDuration`| `Duration` | مدت زمان انیمیشن‌های ورود/خروج. پیش‌فرض 400 میلی‌ثانیه است. |
| `padding` | `EdgeInsetsGeometry` | پدینگ برای محتوای لیست. |
| `physics` | `ScrollPhysics` | فیزیک اسکرول لیست. |
| `reverse` | `bool` | آیا لیست در جهت معکوس اسکرول شود. |
| `scrollDirection`| `Axis` | محوری که لیست در امتداد آن اسکرول می‌شود. |

### متدهای کنترلرها

#### `QuantumWidgetController`
| متد | توضیحات |
| :--- | :--- |
| `add(QuantumEntity entity)` | یک موجودیت ویجت به انتهای لیست اضافه می‌کند. |
| `remove(String id)` | یک موجودیت ویجت را با شناسه منحصر به فردش حذف می‌کند. |
| `update(String id, Widget newWidget)` | ویجت را برای یک شناسه مشخص به صورت اتمی آپدیت می‌کند. |
| `getById(String id)` | یک `QuantumEntity` را با شناسه‌اش بازیابی می‌کند. |
| `scrollTo(String id, ...)`| موقعیت اسکرول را به سمت ویجت با شناسه داده شده انیمیت می‌کند. |
| `clear()` | تمام آیتم‌ها را از لیست حذف می‌کند. |

#### `FilterableQuantumListController<T>`
| متد | توضیحات |
| :--- | :--- |
| `filter(bool Function(T)? test)` | لیست را بر اساس تابع تست فیلتر می‌کند. برای پاک کردن فیلتر، `null` پاس دهید. |
| `sort(int Function(T, T) compare)` | لیست اصلی را مرتب کرده و فیلتر فعلی را دوباره اعمال می‌کند. |
| `add(T item)` | یک آیتم به لیست اصلی و در صورت قبولی در فیلتر، به لیست فیلتر شده اضافه می‌کند. |
| `removeAt(int index)` | یک آیتم را از لیست قابل مشاهده و لیست اصلی حذف می‌کند. |

#### `TimeTravelQuantumWidgetController`
| متد | توضیحات |
| :--- | :--- |
| `undo()` | آخرین تغییر لیست (افزودن، حذف یا آپدیت) را برمی‌گرداند. |
| `redo()` | آخرین تغییر برگردانده شده را دوباره اجرا می‌کند. |
| `travelTo(int commandIndex)` | به یک وضعیت خاص در تاریخچه دستورات می‌پرد. |
| `canUndo` / `canRedo` | `getter`های `bool` برای بررسی در دسترس بودن undo/redo. |
| `historyStream` | استریمی که با هر تغییر در تاریخچه، یک رویداد منتشر می‌کند. |

---

## ۸. به این انقلاب بپیوندید

کوانتوم‌لیست فراتر از یک پکیج است؛ این یک روش تفکر جدید در مورد UI در فلاتر است. این پکیج طوری طراحی شده که قدرتمند، انعطاف‌پذیر و لذت‌بخش برای استفاده باشد.

-   ⭐ برای نشان دادن حمایت خود، به مخزن **ستاره بدهید**!
-   🤔 برای دیدن تمام قابلیت‌ها در عمل، **پروژه `example` را کاوش کنید**.
-   💡 برای گزارش باگ‌ها یا پیشنهاد ویژگی‌های جدید شگفت‌انگیز، یک **issue ایجاد کنید**.

کدنویسی خوش، و باشد که لیست‌هایتان همیشه پویا و زیبا باشند!
